{"version":3,"file":"static/webpack/static/development/pages/index.js.485bf5d24a27318011ed.hot-update.js","sources":["webpack:///./data/PlaylistStore.js"],"sourcesContent":["import xs from \"xstream\";\nimport debounce from \"xstream/extra/debounce\";\nimport sampleCombine from \"xstream/extra/sampleCombine\";\nimport flattenConcurrently from \"xstream/extra/flattenConcurrently\";\nimport _ from \"lodash\";\nimport db from \"./db\";\nimport { user$, fetch$ } from \"./UserStore\";\nimport * as ui from \"./UIStore\";\nimport { selectedPlaylist$ } from \"./UIStore\";\nimport { createEventHandler } from \"../util/recompose\";\nimport * as api from \"./api\";\n\nconst resyncPlaylistsInterval = 1000 * 60 * 10; // 10 minutes\n\nconst { handler: addTag, stream: addTagEvents$ } = createEventHandler();\nexport { addTag };\nconst addedTags$ = addTagEvents$\n  .compose(sampleCombine(fetch$))\n  .map(async ([{ trackId, playlistId }, fetch]) => {\n    const resp = await fetch(\n      `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          uris: [trackId],\n        }),\n      },\n    );\n\n    if (resp.ok) {\n      return { trackId, playlistId };\n    }\n    throw new Error(\"failed to add\");\n  })\n  .map(xs.fromPromise)\n  .compose(flattenConcurrently);\naddedTags$.addListener({\n  async next({ trackId, playlistId }) {\n    const pt = await db.playlistTracks.get(playlistId);\n    if (!pt.trackIds.includes(trackId)) {\n      pt.trackIds.push(trackId);\n      await db.playlistTracks.put(pt);\n    }\n  },\n});\n\nconst { handler: removeTag, stream: removeTagEvents$ } = createEventHandler();\nexport { removeTag };\nconst removedTags$ = removeTagEvents$\n  .compose(sampleCombine(fetch$))\n  .map(async ([{ trackId, playlistId }, fetch]) => {\n    const resp = await fetch(\n      `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,\n      {\n        method: \"DELETE\",\n        body: JSON.stringify({\n          tracks: [{ uri: trackId }],\n        }),\n      },\n    );\n\n    if (resp.ok) {\n      return { trackId, playlistId };\n    }\n    throw new Error(\"failed to remove\");\n  })\n  .map(xs.fromPromise)\n  .compose(flattenConcurrently);\nremovedTags$.addListener({\n  async next({ trackId, playlistId }) {\n    const pt = await db.playlistTracks.get(playlistId);\n    if (pt.trackIds.includes(trackId)) {\n      pt.trackIds = _.without(pt.trackIds, trackId);\n      await db.playlistTracks.put(pt);\n    }\n  },\n});\n\nconst {\n  handler: createAndAddTag,\n  stream: createAndAddTagEvents$,\n} = createEventHandler();\nexport { createAndAddTag };\nconst createdTags$ = createAndAddTagEvents$\n  .compose(sampleCombine(fetch$, user$))\n  .map(async ([{ trackId, playlistName }, fetch, user]) => {\n    const playlist = await api.createPlaylist(fetch, user.id, playlistName);\n    return { trackId, playlist };\n  })\n  .map(xs.fromPromise)\n  .compose(flattenConcurrently)\n  .map(({ trackId, playlist }) =>\n    xs\n      .combine(\n        playlistTracks$\n          .filter(playlistTracks => _.find(playlistTracks, { id: playlist.id }))\n          .take(1),\n        xs.fromPromise(db.playlists.put(playlist)),\n      )\n      .mapTo({ trackId, playlist }),\n  )\n  .compose(flattenConcurrently);\ncreatedTags$.addListener({\n  async next({ trackId, playlist }) {\n    console.log(\"created playlist\", playlist, \"gonna call addTag\");\n    addTag({ trackId, playlistId: playlist.id });\n  },\n\n  error(err) {\n    console.error(\"createAndAddTag\", err.stack);\n  },\n});\n\nasync function fetchPlaylists(\n  fetch,\n  url = \"https://api.spotify.com/v1/me/playlists?limit=50\",\n) {\n  const resp = await fetch(url);\n  const { next, items } = await resp.json();\n\n  let ret = items;\n  if (next) {\n    ret = items.concat(await fetchPlaylists(fetch, next));\n  }\n  return ret;\n}\n\nasync function savePlaylistsToDb(playlists) {\n  await db.playlists.bulkPut(\n    playlists.map((p, index) => ({\n      ...p,\n      index,\n    })),\n  );\n\n  const playlistIds = playlists.map(p => p.id);\n  await db.playlists\n    .where(\"id\")\n    .noneOf(playlistIds)\n    .delete();\n}\n\nconst validFetch$ = fetch$.filter(f => !!f);\nconst invalidFetch$ = fetch$.filter(f => !f);\nconst intervalAfterValidFetch = validFetch$\n  .map(() => {\n    console.log(\"interval before flatten\");\n    return xs.periodic(resyncPlaylistsInterval).startWith(0);\n  })\n  .flatten()\n  .endWhen(invalidFetch$);\n// whenever we have a valid fetch token, refresh playlists\nconst playlistFetches$ = xs\n  .combine(validFetch$, intervalAfterValidFetch)\n  .map(([fetch]) => {\n    console.log(\"fetching playlists\");\n    return fetchPlaylists(fetch);\n  })\n  .map(xs.fromPromise)\n  .flatten();\n\nplaylistFetches$.addListener({\n  next(ps) {\n    if (ps) {\n      // HACK. try switching to xstream\n      console.log(\"fetched playlists\", ps);\n      savePlaylistsToDb(ps);\n    }\n  },\n});\n\nconst playlistChanges$ = xs\n  .create({\n    start(listener) {\n      db.playlists.hook(\"creating\", () => listener.next());\n\n      db.playlists.hook(\"updating\", modifications => {\n        if (_.size(modifications) > 0) {\n          listener.next();\n        }\n      });\n\n      db.playlists.hook(\"deleting\", () => listener.next());\n    },\n    stop() {},\n  })\n  .compose(debounce(0));\n\ndb.playlists.hook(\"deleting\", async key => {\n  console.log(\"playlist deleting\");\n  _.defer(() =>\n    db.playlistTracks\n      .where(\"id\")\n      .equals(key)\n      .delete(),\n  );\n});\n\nexport const playlists$ = playlistChanges$\n  .startWith(undefined)\n  .map(() => {\n    if (process.browser) {\n      console.log(\"get from db\");\n      return db.playlists.toCollection().sortBy(\"index\");\n    }\n    return Promise.resolve([]);\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\n\nplaylists$.addListener({\n  next(playlists) {\n    console.log(\"playlists\", playlists);\n  },\n});\n\nconst playlistTrackChanges$ = xs.create({\n  start(listener) {\n    db.playlistTracks.hook(\"creating\", () => listener.next());\n\n    db.playlistTracks.hook(\"updating\", modifications => {\n      if (_.size(modifications) > 0) {\n        listener.next();\n      }\n    });\n\n    db.playlistTracks.hook(\"deleting\", () => listener.next());\n  },\n  stop() {},\n});\n\nconst playlistTracks$ = playlistTrackChanges$\n  .startWith(undefined)\n  .compose(debounce(30))\n  .map(() => {\n    if (process.browser) {\n      console.log(\"get from db\");\n      return db.playlistTracks.toArray();\n    }\n    return Promise.resolve([]);\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\nplaylistTracks$.addListener({\n  next(pt) {\n    console.log(\"playlisttracks\", pt);\n  },\n});\n\nconst allTracks$ = playlistTracks$\n  .map(playlistTracks => _.uniq(_.flatten(_.map(playlistTracks, \"trackIds\"))))\n  .remember();\nallTracks$.addListener({\n  next(pt) {\n    console.log(\"allTracks\", pt);\n  },\n});\n\nasync function fetchPlaylistTracks(fetch, playlistId, url) {\n  const resp = await fetch(url);\n  const { next, items } = await resp.json();\n\n  let ret = items;\n  if (next) {\n    ret = items.concat(await fetchPlaylistTracks(fetch, playlistId, next));\n  }\n  return ret;\n}\n\nasync function fetchAndSavePlaylistTracks(fetch, playlistId, snapshotId, url) {\n  const tracks = await fetchPlaylistTracks(fetch, playlistId, url);\n  await db.tracks.bulkPut(tracks.map(t => t.track));\n  await db.playlistTracks.put({\n    id: playlistId,\n    snapshot_id: snapshotId,\n    trackIds: tracks.map(t => t.track.uri),\n  });\n}\n\nplaylists$.compose(sampleCombine(playlistTracks$, fetch$)).addListener({\n  next([playlists, playlistTracks, fetch]) {\n    console.log(\"scanning for playlists to fetch\");\n    for (const p of playlists) {\n      if (!_.find(playlistTracks, { id: p.id, snapshot_id: p.snapshot_id })) {\n        console.log(\"couldn't find\", p.id, p.snapshot_id);\n        fetchAndSavePlaylistTracks(fetch, p.id, p.snapshot_id, p.tracks.href);\n      }\n    }\n  },\n});\n\nexport const tagsByTrack$ = playlistTracks$\n  .map(playlistTracks => {\n    const ret = {};\n    for (const { id, trackIds } of playlistTracks) {\n      for (const trackId of trackIds) {\n        if (!ret[trackId]) {\n          ret[trackId] = [];\n        }\n        if (!ret[trackId].includes(id)) {\n          ret[trackId].push(id);\n        }\n      }\n    }\n    return ret;\n  })\n  .remember();\ntagsByTrack$.addListener({\n  next(t) {\n    console.log(\"tagsByTrack\", t);\n  },\n});\n\nconst trackChanges$ = xs.create({\n  start(listener) {\n    db.tracks.hook(\"creating\", () => listener.next());\n\n    db.tracks.hook(\"updating\", modifications => {\n      if (_.size(modifications) > 0) {\n        listener.next();\n      }\n    });\n\n    db.tracks.hook(\"deleting\", () => listener.next());\n  },\n  stop() {},\n});\n\nexport const tracksById$ = trackChanges$\n  .startWith(undefined)\n  .compose(debounce(30))\n  .map(async () => {\n    if (process.browser) {\n      const tracks = await db.tracks.toArray();\n      return _.keyBy(tracks, \"uri\");\n    }\n    return Promise.resolve({});\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\ntracksById$.addListener({\n  next(t) {\n    console.log(\"tracksById\", t);\n  },\n});\n\nexport const filteredTracks$ = xs\n  .combine(selectedPlaylist$, playlistTracks$, allTracks$)\n  .map(([selectedPlaylist, playlistTracks, allTracks]) => {\n    if (selectedPlaylist === \"all\") {\n      return allTracks;\n    }\n    const playlistTrack = playlistTracks.find(pt => pt.id === selectedPlaylist);\n    return playlistTrack ? playlistTrack.trackIds : [];\n  })\n  .combine(ui.searchQuery$)\n  .map(([trackIds, searchQuery]) => {\n    if (!searchQuery) {\n      return trackIds;\n    }\n    return [];\n  })\n  .remember();\nfilteredTracks$.addListener({\n  next(t) {\n    console.log(\"filteredTracks\", t);\n  },\n  error(e) {\n    console.error(e.stack);\n  },\n});\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AADA;AAFA;AACA;AAJA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AADA;AAYA;AAAA;AAAA;AACA;AAbA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAoBA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAEA;AACA;AAHA;AAAA;AAAA;AAAA;AACA;AAGA;AAJA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AADA;AAFA;AACA;AAJA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AADA;AAYA;AAAA;AAAA;AACA;AAbA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAoBA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAEA;AACA;AAHA;AAAA;AAAA;AAAA;AACA;AAGA;AAJA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AAYA;AAFA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAEA;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AARA;AAWA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AARA;AACA;AAUA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AACA;AADA;AAIA;AAJA;AAAA;AACA;AADA;AAAA;AAKA;AAAA;AAEA;AACA;AARA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AASA;AACA;AAVA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAcA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAFA;AAAA;AACA;AAHA;AAQA;AAAA;AAAA;AARA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAeA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAZA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAUA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAZA;AAeA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAHA;AAMA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AACA;AAKA;;;;;;;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAEA;AAAA;AAEA;AACA;AALA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAMA;AACA;AAPA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAWA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAEA;AAAA;AACA;AAHA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AAHA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAUA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AATA;AAYA;AAEA;AADA;AAAA;AAAA;AACA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAWA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAZA;AAeA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAEA;AAFA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;A","sourceRoot":""}