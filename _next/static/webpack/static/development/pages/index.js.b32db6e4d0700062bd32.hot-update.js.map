{"version":3,"file":"static/webpack/static/development/pages/index.js.b32db6e4d0700062bd32.hot-update.js","sources":["webpack:///./data/PlaylistStore.js"],"sourcesContent":["import { observable, autorun, computed, decorate } from \"mobx\";\nimport xs from \"xstream\";\nimport debounce from \"xstream/extra/debounce\";\nimport sampleCombine from \"xstream/extra/sampleCombine\";\nimport flattenConcurrently from \"xstream/extra/flattenConcurrently\";\nimport _ from \"lodash\";\nimport db from \"./db\";\nimport { fetch$ } from \"./UserStore\";\nimport { selectedPlaylist$ } from \"./UIStore\";\nimport { createEventHandler } from \"../util/recompose\";\n\nconst resyncPlaylistsInterval = 1000 * 60 * 10; // 10 minutes\n\nconst { handler: addTag, stream: addTagEvents$ } = createEventHandler();\nexport { addTag };\nconsole.log(\"heyo\", sampleCombine(fetch$));\nconst addedTags$ = addTagEvents$\n  .compose(sampleCombine(fetch$))\n  .map(async ([{ trackId, playlistId }, fetch]) => {\n    return { trackId, playlistId };\n    const resp = await fetch(\n      `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          uris: [trackId],\n        }),\n      },\n    );\n\n    if (resp.ok) {\n      return { trackId, playlistId };\n    }\n    throw new Error(\"failed to add\");\n  })\n  .compose(flattenConcurrently);\naddedTags$.addListener({\n  async next({ trackId, playlistId }) {\n    const pt = await db.playlistTracks.get(playlistId);\n    console.log(\"heyo\", pt);\n  },\n});\n\nasync function fetchPlaylists(\n  fetch,\n  url = \"https://api.spotify.com/v1/me/playlists?limit=50\",\n) {\n  const resp = await fetch(url);\n  const { next, items } = await resp.json();\n\n  let ret = items;\n  if (next) {\n    ret = items.concat(await fetchPlaylists(fetch, next));\n  }\n  return ret;\n}\n\nasync function savePlaylistsToDb(playlists) {\n  await db.playlists.bulkPut(\n    playlists.map((p, index) => ({\n      ...p,\n      index,\n    })),\n  );\n\n  const playlistIds = playlists.map(p => p.id);\n  await db.playlists\n    .where(\"id\")\n    .noneOf(playlistIds)\n    .delete();\n}\n\nconst validFetch$ = fetch$.filter(f => !!f);\nconst invalidFetch$ = fetch$.filter(f => !f);\nconst intervalAfterValidFetch = validFetch$\n  .map(() => {\n    console.log(\"interval before flatten\");\n    return xs.periodic(resyncPlaylistsInterval).startWith(0);\n  })\n  .flatten()\n  .endWhen(invalidFetch$);\n// whenever we have a valid fetch token, refresh playlists\nconst playlistFetches$ = xs\n  .combine(validFetch$, intervalAfterValidFetch)\n  .map(([fetch]) => {\n    console.log(\"fetching playlists\");\n    return fetchPlaylists(fetch);\n  })\n  .map(xs.fromPromise)\n  .flatten();\n\nplaylistFetches$.addListener({\n  next(ps) {\n    if (ps) {\n      // HACK. try switching to xstream\n      console.log(\"fetched playlists\", ps);\n      savePlaylistsToDb(ps);\n    }\n  },\n});\n\nconst playlistChanges$ = xs.create({\n  start(listener) {\n    db.playlists.hook(\"creating\", () => listener.next());\n\n    db.playlists.hook(\"updating\", modifications => {\n      if (_.size(modifications) > 0) {\n        listener.next();\n      }\n    });\n\n    db.playlists.hook(\"deleting\", () => listener.next());\n  },\n  stop() {},\n});\n\ndb.playlists.hook(\"deleting\", async key => {\n  console.log(\"playlist deleting\");\n  _.defer(() =>\n    db.playlistTracks\n      .where(\"id\")\n      .equals(key)\n      .delete(),\n  );\n});\n\nexport const playlists$ = playlistChanges$\n  .startWith(undefined)\n  .compose(debounce(30))\n  .map(() => {\n    if (process.browser) {\n      console.log(\"get from db\");\n      return db.playlists.toCollection().sortBy(\"index\");\n    }\n    return Promise.resolve([]);\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\n\nplaylists$.addListener({\n  next(playlists) {\n    console.log(\"playlists\", playlists);\n  },\n});\n\nconst playlistTrackChanges$ = xs.create({\n  start(listener) {\n    db.playlistTracks.hook(\"creating\", () => listener.next());\n\n    db.playlistTracks.hook(\"updating\", modifications => {\n      if (_.size(modifications) > 0) {\n        listener.next();\n      }\n    });\n\n    db.playlistTracks.hook(\"deleting\", () => listener.next());\n  },\n  stop() {},\n});\n\nconst playlistTracks$ = playlistTrackChanges$\n  .startWith(undefined)\n  .compose(debounce(30))\n  .map(() => {\n    if (process.browser) {\n      console.log(\"get from db\");\n      return db.playlistTracks.toArray();\n    }\n    return Promise.resolve([]);\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\nplaylistTracks$.addListener({\n  next(pt) {\n    console.log(\"playlisttracks\", pt);\n  },\n});\n\nconst allTracks$ = playlistTracks$\n  .map(playlistTracks => _.uniq(_.flatten(_.map(playlistTracks, \"trackIds\"))))\n  .remember();\nallTracks$.addListener({\n  next(pt) {\n    console.log(\"allTracks\", pt);\n  },\n});\n\nasync function fetchPlaylistTracks(fetch, playlistId, url) {\n  const resp = await fetch(url);\n  const { next, items } = await resp.json();\n\n  let ret = items;\n  if (next) {\n    ret = items.concat(await fetchPlaylistTracks(fetch, playlistId, next));\n  }\n  return ret;\n}\n\nasync function fetchAndSavePlaylistTracks(fetch, playlistId, snapshotId, url) {\n  const tracks = await fetchPlaylistTracks(fetch, playlistId, url);\n  await db.tracks.bulkPut(tracks.map(t => t.track));\n  await db.playlistTracks.put({\n    id: playlistId,\n    snapshot_id: snapshotId,\n    trackIds: tracks.map(t => t.track.uri),\n  });\n}\n\nplaylistFetches$.compose(sampleCombine(playlistTracks$, fetch$)).addListener({\n  next([playlists, playlistTracks, fetch]) {\n    console.log(\"after playlist fetch\");\n    for (const p of playlists) {\n      if (!_.find(playlistTracks, { id: p.id, snapshot_id: p.snapshot_id })) {\n        console.log(\"couldn't find\", p.id, p.snapshot_id);\n        fetchAndSavePlaylistTracks(fetch, p.id, p.snapshot_id, p.tracks.href);\n      }\n    }\n  },\n});\n\nexport const tagsByTrack$ = playlistTracks$\n  .map(playlistTracks => {\n    const ret = {};\n    for (const { id, trackIds } of playlistTracks) {\n      for (const trackId of trackIds) {\n        if (!ret[trackId]) {\n          ret[trackId] = [];\n        }\n        if (!ret[trackId].includes(id)) {\n          ret[trackId].push(id);\n        }\n      }\n    }\n    return ret;\n  })\n  .remember();\ntagsByTrack$.addListener({\n  next(t) {\n    console.log(\"tagsByTrack\", t);\n  },\n});\n\nconst trackChanges$ = xs.create({\n  start(listener) {\n    db.tracks.hook(\"creating\", () => listener.next());\n\n    db.tracks.hook(\"updating\", modifications => {\n      if (_.size(modifications) > 0) {\n        listener.next();\n      }\n    });\n\n    db.tracks.hook(\"deleting\", () => listener.next());\n  },\n  stop() {},\n});\n\nexport const tracksById$ = trackChanges$\n  .startWith(undefined)\n  .compose(debounce(30))\n  .map(async () => {\n    if (process.browser) {\n      const tracks = await db.tracks.toArray();\n      return _.keyBy(tracks, \"uri\");\n    }\n    return Promise.resolve({});\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\ntracksById$.addListener({\n  next(t) {\n    console.log(\"tracksById\", t);\n  },\n});\n\nexport const filteredTracks$ = xs\n  .combine(selectedPlaylist$, playlistTracks$, allTracks$)\n  .map(([selectedPlaylist, playlistTracks, allTracks]) => {\n    if (selectedPlaylist === \"all\") {\n      return allTracks;\n    }\n    return playlistTracks.find(pt => pt.id === selectedPlaylist).trackIds;\n  })\n  .remember();\nfilteredTracks$.addListener({\n  next(t) {\n    console.log(\"filteredTracks\", t);\n  },\n  error(e) {\n    console.error(e.stack);\n  },\n});\n\nexport default class PlaylistStore {\n  constructor() {\n    this.playlists = [];\n    this.tracksByPlaylist = {};\n    this.tracksById = {};\n    this.searchState = observable({\n      query: \"\",\n      selectedPlaylistId: \"all\",\n      numFetches: 0,\n    });\n    this.user = {};\n  }\n\n  get playlistsById() {\n    return _.keyBy(this.playlists, \"id\");\n  }\n\n  get playlistSelectValues() {\n    return this.playlists.map(p => ({ value: p.id, label: p.name }));\n  }\n\n  get playlistIds() {\n    return this.playlists.map(p => p.id);\n  }\n\n  get allTracks() {\n    return _.uniqBy(_.flatten(Object.values(this.tracksByPlaylist)), t => t);\n  }\n\n  get tagsByTrack() {\n    const ret = {};\n\n    _.forEach(this.tracksByPlaylist, (trackIds, playlistId) => {\n      trackIds.forEach(uri => {\n        if (!ret[uri]) {\n          ret[uri] = [];\n        }\n\n        if (!ret[uri].includes(playlistId)) {\n          ret[uri].push(playlistId);\n        }\n      });\n    });\n\n    return ret;\n  }\n\n  get filteredTracks() {\n    const tracksForSelectedList =\n      (this.searchState.selectedPlaylistId === \"all\"\n        ? this.allTracks\n        : this.tracksByPlaylist[this.searchState.selectedPlaylistId]) || [];\n\n    // TODO\n    const filteredList = tracksForSelectedList;\n    // const filteredList = this.searchState.query\n    //   ? tracksForSelectedList.filter(t => {\n    //       const query = this.searchState.query.toLowerCase();\n    //       return (\n    //         t.track.name.toLowerCase().includes(query) ||\n    //         _.some(t.track.artists, a => a.name.toLowerCase().includes(query))\n    //       );\n    //     })\n    //   : tracksForSelectedList;\n\n    return filteredList;\n  }\n\n  addTag = async (trackUri, playlistId) => {\n    const resp = await fetch(\n      `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          uris: [trackUri],\n        }),\n      },\n    );\n\n    if (resp.ok) {\n      const add = () => this.tracksByPlaylist[playlistId].push(trackUri);\n      if (this.tracksByPlaylist[playlistId]) {\n        add();\n      } else {\n        // we're probably fetching the playlist\n        const dispose = autorun(() => {\n          if (this.tracksByPlaylist[playlistId]) {\n            dispose();\n            add();\n          }\n        });\n      }\n    } else {\n    }\n  };\n\n  removeTag = async (trackUri, playlistId) => {\n    const resp = await fetch(\n      `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,\n      {\n        method: \"DELETE\",\n        body: JSON.stringify({\n          tracks: [{ uri: trackUri }],\n        }),\n      },\n    );\n\n    if (resp.ok) {\n      this.tracksByPlaylist[playlistId] = this.tracksByPlaylist[\n        playlistId\n      ].filter(uri => uri !== trackUri);\n    } else {\n    }\n  };\n\n  createTagWithTrack = async (trackUri, playlistName) => {\n    const resp = await fetch(\n      `https://api.spotify.com/v1/users/${this.user.id}/playlists`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          name: playlistName,\n          description: \"Created by Tagify.\",\n        }),\n      },\n    );\n    if (!resp.ok) {\n      throw new Error(\"Couldn't create tag\");\n    }\n\n    const playlist = await resp.json();\n    this.playlists.push(playlist);\n\n    this.addTag(trackUri, playlist.id);\n  };\n}\n\ndecorate(PlaylistStore, {\n  playlists: observable,\n  tracksByPlaylist: observable,\n  tracksById: observable,\n  playlistsById: computed,\n  playlistIds: computed,\n  allTracks: computed,\n  tagsByTrack: computed,\n  filteredTracks: computed,\n});\n"],"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAWA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAZA;AAeA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAEA;AAFA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;;;AACA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AADA;AAFA;AACA;AAJA;AACA;AACA;AASA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AApEA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAAA;AADA;AAFA;AACA;AAJA;AACA;AACA;AASA;AACA;AAEA;AAAA;AACA;AACA;AAhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAhGA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AAFA;AAFA;AACA;AAJA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAeA;AACA;AAAA;AACA;AACA;AACA;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAnHA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;AACA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAlEA;AAyIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;;;A","sourceRoot":""}