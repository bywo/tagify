{"version":3,"file":"static/webpack/static/development/pages/index.js.ad4c567c21a2d9815311.hot-update.js","sources":["webpack:///./data/PlaylistStore.js"],"sourcesContent":["import xs from \"xstream\";\nimport debounce from \"xstream/extra/debounce\";\nimport sampleCombine from \"xstream/extra/sampleCombine\";\nimport flattenConcurrently from \"xstream/extra/flattenConcurrently\";\nimport _ from \"lodash\";\nimport db from \"./db\";\nimport { user$, fetch$ } from \"./UserStore\";\nimport * as ui from \"./UIStore\";\nimport { selectedPlaylist$ } from \"./UIStore\";\nimport { createEventHandler } from \"../util/recompose\";\nimport * as api from \"./api\";\n\nconst resyncPlaylistsInterval = 1000 * 60 * 10; // 10 minutes\n\nconst { handler: onError, stream: errors$ } = createEventHandler();\nconst {\n  handler: dismissError,\n  stream: errorDismissals$,\n} = createEventHandler();\nexport { dismissError };\n\nexport const errorList$ = xs\n  .merge(\n    errors$.map(err => ({ type: \"newError\", payload: err })),\n    errorDismissals$.map(err => ({ type: \"dismissError\", payload: err })),\n  )\n  .fold((errorList, action) => {\n    if (action.type === \"newError\") {\n      return [...errorList, action.payload];\n    }\n    return _.without(errorList, action.payload);\n  }, []);\n\nconst forwardErrorToErrorCollector = response$ =>\n  response$.replaceError(err => {\n    onError(err);\n    return xs.of();\n  });\n\nconst { handler: addTag, stream: addTagEvents$ } = createEventHandler();\nexport { addTag, addTagEvents$ };\nconst addedTags$ = addTagEvents$\n  .compose(sampleCombine(fetch$))\n  .map(async ([{ trackId, playlistId }, fetch]) => {\n    await api.addToPlaylist(fetch, playlistId, trackId);\n    return { trackId, playlistId };\n  })\n  .map(xs.fromPromise)\n  .map(forwardErrorToErrorCollector)\n  .compose(flattenConcurrently);\naddedTags$.addListener({\n  async next({ trackId, playlistId }) {\n    const pt = await db.playlistTracks.get(playlistId);\n    if (!pt.trackIds.includes(trackId)) {\n      pt.trackIds.push(trackId);\n      await db.playlistTracks.put(pt);\n    }\n  },\n});\n\nconst { handler: removeTag, stream: removeTagEvents$ } = createEventHandler();\nexport { removeTag, removeTagEvents$ };\nconst removedTags$ = removeTagEvents$\n  .compose(sampleCombine(fetch$))\n  .map(async ([{ trackId, playlistId }, fetch]) => {\n    await api.removeFromPlaylist(fetch, playlistId, trackId);\n    return { trackId, playlistId };\n  })\n  .map(xs.fromPromise)\n  .map(forwardErrorToErrorCollector)\n  .compose(flattenConcurrently);\nremovedTags$.addListener({\n  async next({ trackId, playlistId }) {\n    const pt = await db.playlistTracks.get(playlistId);\n    if (pt.trackIds.includes(trackId)) {\n      pt.trackIds = _.without(pt.trackIds, trackId);\n      await db.playlistTracks.put(pt);\n    }\n  },\n});\n\nconst {\n  handler: createAndAddTag,\n  stream: createAndAddTagEvents$,\n} = createEventHandler();\nexport { createAndAddTag, createAndAddTagEvents$ };\nconst createdTags$ = createAndAddTagEvents$\n  .compose(sampleCombine(fetch$, user$))\n  .map(async ([{ trackId, playlistName }, fetch, user]) => {\n    const playlist = await api.createPlaylist(fetch, user.id, playlistName);\n    return { trackId, playlist };\n  })\n  .map(xs.fromPromise)\n  .map(forwardErrorToErrorCollector)\n  .compose(flattenConcurrently)\n  .map(({ trackId, playlist }) =>\n    xs\n      .combine(\n        playlistTracks$\n          .filter(playlistTracks => _.find(playlistTracks, { id: playlist.id }))\n          .take(1),\n        xs.fromPromise(db.playlists.put(playlist)),\n      )\n      .mapTo({ trackId, playlist }),\n  )\n  .compose(flattenConcurrently);\ncreatedTags$.addListener({\n  async next({ trackId, playlist }) {\n    addTag({ trackId, playlistId: playlist.id });\n  },\n\n  error(err) {\n    console.error(\"createAndAddTag\", err.stack);\n  },\n});\n\nasync function savePlaylistsToDb(playlists) {\n  await db.playlists.bulkPut(\n    playlists.map((p, index) => ({\n      ...p,\n      index,\n    })),\n  );\n\n  const playlistIds = playlists.map(p => p.id);\n  await db.playlists\n    .where(\"id\")\n    .noneOf(playlistIds)\n    .delete();\n}\n\nconst validFetch$ = fetch$.filter(f => !!f);\nconst invalidFetch$ = fetch$.filter(f => !f);\nconst intervalAfterValidFetch = validFetch$\n  .map(() => xs.periodic(resyncPlaylistsInterval).startWith(0))\n  .flatten()\n  .endWhen(invalidFetch$);\n// whenever we have a valid fetch token, refresh playlists\nconst playlistFetches$ = xs\n  .combine(validFetch$, intervalAfterValidFetch)\n  .map(([fetch]) => api.fetchPlaylists(fetch))\n  .map(xs.fromPromise)\n  .flatten();\n\nplaylistFetches$.addListener({\n  next(ps) {\n    if (ps) {\n      savePlaylistsToDb(ps);\n    }\n  },\n});\n\nconst playlistChanges$ = xs\n  .create({\n    start(listener) {\n      db.playlists.hook(\"creating\", () => listener.next());\n\n      db.playlists.hook(\"updating\", modifications => {\n        if (_.size(modifications) > 0) {\n          listener.next();\n        }\n      });\n\n      db.playlists.hook(\"deleting\", () => listener.next());\n    },\n    stop() {},\n  })\n  .compose(debounce(0));\n\ndb.playlists.hook(\"deleting\", async key => {\n  _.defer(() =>\n    db.playlistTracks\n      .where(\"id\")\n      .equals(key)\n      .delete(),\n  );\n});\n\nexport const playlists$ = playlistChanges$\n  .startWith(undefined)\n  .map(() => {\n    if (process.browser) {\n      return db.playlists.toCollection().sortBy(\"index\");\n    }\n    return Promise.resolve([]);\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\n\nconst playlistTrackChanges$ = xs.create({\n  start(listener) {\n    db.playlistTracks.hook(\"creating\", () => listener.next());\n\n    db.playlistTracks.hook(\"updating\", modifications => {\n      if (_.size(modifications) > 0) {\n        listener.next();\n      }\n    });\n\n    db.playlistTracks.hook(\"deleting\", () => listener.next());\n  },\n  stop() {},\n});\n\nconst playlistTracks$ = playlistTrackChanges$\n  .startWith(undefined)\n  .compose(debounce(30))\n  .map(() => {\n    if (process.browser) {\n      return db.playlistTracks.toArray();\n    }\n    return Promise.resolve([]);\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\n\nconst allTracks$ = playlistTracks$\n  .map(playlistTracks => _.uniq(_.flatten(_.map(playlistTracks, \"trackIds\"))))\n  .remember();\n\nasync function fetchAndSavePlaylistTracks(fetch, playlistId, snapshotId, url) {\n  const tracks = await api.fetchPlaylistTracks(fetch, playlistId, url);\n  await db.tracks.bulkPut(tracks.map(t => t.track));\n  await db.playlistTracks.put({\n    id: playlistId,\n    snapshot_id: snapshotId,\n    trackIds: tracks.map(t => t.track.uri),\n  });\n}\n\nplaylists$.compose(sampleCombine(playlistTracks$, fetch$)).addListener({\n  next([playlists, playlistTracks, fetch]) {\n    for (const p of playlists) {\n      if (!_.find(playlistTracks, { id: p.id, snapshot_id: p.snapshot_id })) {\n        fetchAndSavePlaylistTracks(fetch, p.id, p.snapshot_id, p.tracks.href);\n      }\n    }\n  },\n});\n\nexport const tagsByTrack$ = playlistTracks$\n  .map(playlistTracks => {\n    const ret = {};\n    for (const { id, trackIds } of playlistTracks) {\n      for (const trackId of trackIds) {\n        if (!ret[trackId]) {\n          ret[trackId] = [];\n        }\n        if (!ret[trackId].includes(id)) {\n          ret[trackId].push(id);\n        }\n      }\n    }\n    return ret;\n  })\n  .remember();\n\nconst trackChanges$ = xs.create({\n  start(listener) {\n    db.tracks.hook(\"creating\", () => listener.next());\n\n    db.tracks.hook(\"updating\", modifications => {\n      if (_.size(modifications) > 0) {\n        listener.next();\n      }\n    });\n\n    db.tracks.hook(\"deleting\", () => listener.next());\n  },\n  stop() {},\n});\n\nexport const tracksById$ = trackChanges$\n  .startWith(undefined)\n  .compose(debounce(30))\n  .map(async () => {\n    if (process.browser) {\n      const tracks = await db.tracks.toArray();\n      return _.keyBy(tracks, \"uri\");\n    }\n    return Promise.resolve({});\n  })\n  .map(xs.fromPromise)\n  .flatten()\n  .remember();\n\nexport const filteredTracks$ = xs\n  .combine(\n    selectedPlaylist$,\n    playlistTracks$,\n    allTracks$,\n    tracksById$,\n    ui.searchQuery$,\n  )\n  .map(\n    ([\n      selectedPlaylist,\n      playlistTracks,\n      allTracks,\n      tracksById,\n      searchQuery,\n    ]) => {\n      let tracks;\n      if (selectedPlaylist === \"all\") {\n        tracks = allTracks;\n      } else {\n        const playlistTrack = playlistTracks.find(\n          pt => pt.id === selectedPlaylist,\n        );\n        tracks = playlistTrack ? playlistTrack.trackIds : [];\n      }\n\n      if (!searchQuery) {\n        return tracks;\n      }\n      return tracks.filter(trackId => {\n        const track = tracksById[trackId];\n        return track && trackMatchesQuery(track, searchQuery);\n      });\n    },\n  )\n  .remember();\n\nfilteredTracks$.addListener({\n  next() {\n    console.log(\"refiltered tracks\");\n  },\n\n  error(err) {\n    console.log(\"error filtering tracks\", err);\n  },\n});\n\nfunction trackMatchesQuery(track, query) {\n  return (\n    track.name.toLowerCase().includes(query.toLowerCase()) ||\n    (track.artists &&\n      track.artists.some(artist =>\n        artist.name.toLowerCase().includes(query.toLowerCase()),\n      ))\n  );\n}\n"],"mappings":"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","sourceRoot":""}